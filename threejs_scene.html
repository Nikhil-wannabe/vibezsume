<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Scene</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: transparent; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="threejsCanvas"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        // OrbitControls are optional, but good for testing/interaction if desired later
        // import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, mesh;
        const canvas = document.getElementById('threejsCanvas');

        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            const fov = 75;
            const aspect = canvas.clientWidth / canvas.clientHeight || 1; // Default aspect if canvas has no size yet
            const near = 0.1;
            const far = 1000;
            camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.z = 3; // Adjusted for IcosahedronGeometry size

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true }); // alpha: true for transparent background
            renderer.setPixelRatio(window.devicePixelRatio);
            // Set initial size - this will be overridden by Streamlit component dimensions if possible,
            // but good for standalone testing.
            renderer.setSize(canvas.clientWidth || 300, canvas.clientHeight || 300);


            // Geometry - Icosahedron for a slightly more complex shape than a cube
            const geometry = new THREE.IcosahedronGeometry(1, 0); // radius 1, detail 0

            // Material - A slightly reflective material
            const material = new THREE.MeshStandardMaterial({
                color: 0x4CAF50, // Greenish color, similar to app theme
                metalness: 0.3,
                roughness: 0.6,
                flatShading: false // Smooth shading
            });

            mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // Soft white light
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(1, 2, 3); // coming from top right, front
            scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-3, -1, -2); // coming from bottom left, back
            scene.add(directionalLight2);


            // Optional: OrbitControls for manual interaction (if you uncomment the import)
            // const controls = new OrbitControls(camera, renderer.domElement);
            // controls.enableDamping = true;
            // controls.dampingFactor = 0.05;
            // controls.screenSpacePanning = false;
            // controls.minDistance = 2;
            // controls.maxDistance = 10;

            // Handle window resize (or canvas resize by Streamlit component)
            // This is a bit tricky with Streamlit's iframe for components.
            // The component's width/height might be fixed by Streamlit.
            // If using a resizable container, this would be more relevant.
            // For now, we assume Streamlit sets the canvas size via the component's height/width args.
            // A ResizeObserver could be more robust if the canvas itself is directly resizable.

            // A function to explicitly set size if Streamlit can call it or if dimensions are passed
            window.setThreeJSCanvasSize = function(width, height) {
                if (renderer && camera) {
                    renderer.setSize(width, height);
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                }
            }
            // Call it once with initial parent size if available, Streamlit might override
             if (canvas.parentElement) {
                 window.setThreeJSCanvasSize(canvas.parentElement.clientWidth, canvas.parentElement.clientHeight);
             }


            // Start animation loop
            renderer.setAnimationLoop(animate);
        }

        function animate() {
            if (mesh) {
                mesh.rotation.x += 0.005;
                mesh.rotation.y += 0.007;
            }
            // if (controls) controls.update(); // If OrbitControls are used
            renderer.render(scene, camera);
        }

        // Check if canvas is available before initializing
        if (canvas) {
            init();
        } else {
            console.error("Three.js canvas element not found.");
        }

    </script>
</body>
</html>
